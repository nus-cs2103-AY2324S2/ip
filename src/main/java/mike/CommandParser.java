package mike;

import java.util.List;

import mike.command.*;

/**
 * CommandParser is the class responsible for parsing the command input and generating {@link Command} objects,
 * @author ningc
 */
class CommandParser {
    private final List<Token> tokens;
    private int current;

    /**
     * Constructor.
     * @param tokens List of tokens generated by {@link CommandScanner}.
     */
    CommandParser(List<Token> tokens) {
        this.tokens = tokens;
        this.current = 0;
    }

    /**
     * Parses the token list to generate a Command object which is returned.
     * @return Command that can be executed.
     * @throws MikeException If there is no command input or the command is not recognized.
     */
    public Command parse() throws MikeException {
        Token commandToken = advance();
        TokenType commandTokenType = commandToken.getType();

        switch (commandTokenType) {
        case EXIT:
            return parseExit();
        case LIST:
            return parseList();
        case MARK:
            return parseMark();
        case UNMARK:
            return parseUnmark();
        case TODO:
            return parseTodo();
        case DEADLINE:
            return parseDeadline();
        case EVENT:
            return parseEvent();
        case DELETE:
            return parseDelete();
        case FIND:
            return parseFind();
        case ARCHIVE:
            return parseArchive();
        case EOC:
            throw createError("Say something.");
        default:
            String errorMessage = createInvalidCommandErrorMessage(commandToken);
            throw createError(errorMessage);
        }
    }

    private Command parseExit() throws MikeException {
        consume(TokenType.EOC, "Usage: bye");
        return new ExitCommand();
    }

    private Command parseList() throws MikeException {
        String basicListUsage = "Usage: list";
        String fullListUsage = "Usage: list /view [type] /attribute [attribute]";

        if (!getParameterSeen()) {
            consume(TokenType.EOC, basicListUsage);
            return new ListCommand(new ListView(ListViewType.NONE));
        }

        if (!getHasParameterName("view")) {
            throw createError(fullListUsage);
        }

        ListViewType listViewType = getListViewType(fullListUsage);
        consumeParameter("attribute", fullListUsage);
        String attribute = getLiteral(fullListUsage);
        consume(TokenType.EOC, fullListUsage);

        ListView listView = new ListView(listViewType, attribute);
        return new ListCommand(listView);
    }

    private ListViewType getListViewType(String commandUsage) throws MikeException {
        String type = getLiteral(commandUsage);

        switch (type) {
        case "date":
            return ListViewType.DATE;
        case "description":
            return ListViewType.DESCRIPTION;
        default:
            throw createError("Invalid type");
        }
    }

    private Command parseMark() throws MikeException {
        String usage = "Usage: mark [number]";

        String argument = getLiteral(usage);
        consume(TokenType.EOC, usage);
        try {
            int taskNumber = Integer.parseInt(argument);
            return new MarkCommand(taskNumber);
        } catch (NumberFormatException e) {
            String errorMessage = createInvalidNumberErrorMessage(argument);
            throw createError(errorMessage);
        }
    }

    private Command parseUnmark() throws MikeException {
        String usage = "Usage: unmark [number]";

        String argument = getLiteral(usage);
        consume(TokenType.EOC, usage);
        try {
            int taskNumber = Integer.parseInt(argument);
            return new UnmarkCommand(taskNumber);
        } catch (NumberFormatException e) {
            String errorMessage = createInvalidNumberErrorMessage(argument);
            throw createError(errorMessage);
        }
    }

    private Command parseTodo() throws MikeException {
        String usage = "Usage: todo [description]";

        String description = getLiteral("Description missing.\n" + usage);
        consume(TokenType.EOC, usage);
        return new AddTodoCommand(description);
    }

    private Command parseDeadline() throws MikeException {
        String usage = "Usage: deadline [description] /by [date]";

        String description = getLiteral("Description missing.\n" + usage);
        consumeParameter("by", usage);
        String deadline = getLiteral(usage);
        consume(TokenType.EOC, usage);
        return new AddDeadlineCommand(description, deadline);
    }

    private Command parseEvent() throws MikeException {
        String usage = "Usage: event [description] /from [date] /to [date]";

        String description = getLiteral("Description missing.\n" + usage);

        consumeParameter("from", usage);

        String startDate = getLiteral("Start date missing.\n" + usage);

        consumeParameter("to", usage);

        String endDate = getLiteral("End date missing.\n" + usage);
        consume(TokenType.EOC, usage);
        return new AddEventCommand(description, startDate, endDate);
    }

    private Command parseDelete() throws MikeException {
        String usage = "Usage: delete [number]";
        String argument = getLiteral(usage);
        consume(TokenType.EOC, usage);

        try {
            int taskNumber = Integer.parseInt(argument);
            return new DeleteCommand(taskNumber);
        } catch (NumberFormatException e) {
            String errorMessage = createInvalidNumberErrorMessage(argument);
            throw createError(errorMessage);
        }
    }

    private Command parseFind() throws MikeException {
        String basicFindUsage = "Usage: find [keyword]";
        String fullFindUsage = "Usage: find [keyword] /fuzzy [on/off]";

        String keyword = getLiteral(basicFindUsage);

        if (!getParameterSeen()) {
            consume(TokenType.EOC, basicFindUsage);
            return new FindCommand(keyword, false);
        }

        if (!getHasParameterName("fuzzy")) {
            throw createError(fullFindUsage);
        }

        String argument = getLiteral(fullFindUsage);
        consume(TokenType.EOC, fullFindUsage);

        switch (argument) {
        case "on":
            return new FindCommand(keyword, true);
        case "off":
            return new FindCommand(keyword, false);
        default:
            throw createError(fullFindUsage);
        }
    }

    private Command parseArchive() throws MikeException {
        String usage = "Usage: archive [filename]";
        String archiveFileName = getLiteral(usage);
        consume(TokenType.EOC, usage);
        return new ArchiveCommand(archiveFileName);
    }

    private boolean match(TokenType...types) {
        for (TokenType type : types) {
            if (check(type)) {
                advance();
                return true;
            }
        }

        return false;
    }

    private MikeException createError(String message) {
        return new MikeException(message);
    }

    private String createInvalidCommandErrorMessage(Token invalidCommandToken) {
        return "'" + invalidCommandToken.getText() + "' is not recognized as a command.\n"
                + "That is the weirdest thing you've ever said.";
    }

    private String createInvalidNumberErrorMessage(String argument) {
        return "One, two, three, four, get the kid back through the door!\n'"
                + argument + "' is not an integer Sulley...";
    }

    private Token consume(TokenType type, String message) throws MikeException {
        if (check(type)) {
            return advance();
        }
        throw createError(message);
    }

    private boolean check(TokenType type) {
        return peekToken().getType() == type;
    }

    private Token advance() {
        if (!isAtEnd()) {
            current++;
        }
        return previousToken();
    }

    private Token previousToken() {
        return tokens.get(current - 1);
    }

    private boolean isAtEnd() {
        return peekToken().getType() == TokenType.EOC;
    }

    private Token peekToken() {
        return tokens.get(current);
    }

    private void consumeParameter(String parameterName, String commandUsage) throws MikeException {
        consume(TokenType.FORWARD_DASH, commandUsage);
        consume(TokenType.PARAM, commandUsage);
        if (!getHasParameterName("from")) {
            throw createError(commandUsage);
        }
    }

    private String getLiteral(String commandUsage) throws MikeException {
        consume(TokenType.LITERAL, commandUsage);
        return previousToken().getText().strip();
    }

    private boolean getHasParameterName(String parameterName) {
        Token paramToken = previousToken();
        return paramToken.getText().equals(parameterName);
    }

    private boolean getParameterSeen() {
        return match(TokenType.FORWARD_DASH) && match(TokenType.PARAM);
    }
}
